==================================================
1. Signature-Based Detection
==================================================
How it works:
- Compares file hashes or byte patterns (signatures) to a database of known malware.
- Usually works on static files before execution.

What it detects:
- Known malware with fixed or common code.
- Unchanged or poorly obfuscated payloads.
- Reused packers or known binary patterns.

Evasion Techniques:
- Change the file hash by recompiling or padding.
- Use packers or crypters to obfuscate code.
- Polymorphism (change binary structure every time).
- Encrypt or encode payloads and decrypt at runtime.

Evasion Difficulty Rank: 2/10

--------------------------------------------------

==================================================
2. Heuristic-Based Detection
==================================================
How it works:
- Scans code for suspicious characteristics or instruction patterns.
- Uses rules based on what “malicious” code typically looks like.
- Often used when no signature match is found.

What it detects:
- Unusual API usage (e.g., VirtualAlloc + WriteProcessMemory).
- Suspicious control flow or inline assembly.
- Obfuscated strings or shellcode loaders.

Evasion Techniques:
- Split or delay malicious API calls.
- Resolve APIs dynamically instead of importing statically.
- Obfuscate control flow and use legitimate APIs.
- Use compiler trickery to hide suspicious patterns.

Evasion Difficulty Rank: 4/10

--------------------------------------------------

==================================================
3. Behavioral-Based Detection
==================================================
How it works:
- Monitors actions during runtime in a sandbox or live environment.
- Detects suspicious behaviors like code injection, registry changes, or network beacons.

What it detects:
- Process hollowing, injection, persistence techniques.
- Suspicious registry or file modifications.
- Malicious PowerShell or LOLBin activity.

Evasion Techniques:
- Use sleep/delay to outlast sandboxes.
- Detect sandbox/VM via environment checks.
- Require user interaction before payload execution.
- Stagger or mimic legitimate behavior.

Evasion Difficulty Rank: 6/10

--------------------------------------------------

==================================================
4. Cloud-Based Reputation Systems
==================================================
How it works:
- Checks file hash, URL, or IP against an online threat intelligence database.
- Can block execution of files with low or unknown reputation.

What it detects:
- New or unsigned executables.
- Connections to known C2 servers.
- Files downloaded from suspicious sources.

Evasion Techniques:
- Frequently recompile binaries to change hash.
- Use custom, domain-fronted, or fast-flux C2s.
- Sign binaries with stolen or self-signed certs.
- Use local execution and avoid internet until needed.

Evasion Difficulty Rank: 5/10

--------------------------------------------------

==================================================
5. Memory Forensics and Scanning
==================================================
How it works:
- Scans process memory for shellcode, injected DLLs, or suspicious strings.
- EDRs dump and analyze memory snapshots in real time.

What it detects:
- Reflective DLL injection.
- Shellcode and RWX memory regions.
- Unlinked modules or PE artifacts in memory.

Evasion Techniques:
- Encrypt payloads in memory; decrypt only before execution.
- Avoid RWX memory (use RX-only and execute from there).
- Use manual mapping instead of LoadLibrary.
- Clear artifacts and unlink injected modules.

Evasion Difficulty Rank: 8/10

--------------------------------------------------

==================================================
6. Telemetry Correlation / EDR Analytics
==================================================
How it works:
- Collects event data (process creation, file writes, registry edits).
- Correlates sequences over time to identify malicious chains.
- Tracks parent/child processes, scripting engines, and privilege changes.

What it detects:
- Malicious process trees (e.g., Word → PowerShell → C2).
- Unusual privilege escalation or lateral movement.
- Abnormal usage of system tools or scripting.

Evasion Techniques:
- Use LOLBins to stay within native tools.
- Chain actions across time and processes to avoid correlation.
- Mimic known-good process trees (e.g., rundll32, msiexec).
- Inject into legitimate processes to break traceability.

Evasion Difficulty Rank: 9/10

--------------------------------------------------

==================================================
7. Machine Learning (ML)-Based Detection
==================================================
How it works:
- Uses statistical models to classify files or behaviors as malicious or benign.
- Trained on thousands or millions of malware and clean samples.

What it detects:
- Malicious features, even if the malware is new or obfuscated.
- Common structural elements of malware families.

Evasion Techniques:
- Use adversarial ML fuzzing to test payloads offline.
- Modify binary features to resemble clean files.
- Randomize non-functional parts of the code.
- Use packers that confuse ML feature extraction.

Evasion Difficulty Rank: 7/10

--------------------------------------------------

==================================================
8. YARA and Custom Rule Detection
==================================================
How it works:
- Uses pattern-matching rules written by analysts to detect malware.
- Rules can match strings, PE headers, metadata, or binary logic.

What it detects:
- Specific malware families or behaviors.
- Known keywords, strings, or payload structure.

Evasion Techniques:
- Break up string patterns or encrypt them.
- Change section names, timestamps, headers.
- Randomize payload layout and metadata.
- Test payloads against YARA rules before deployment.

Evasion Difficulty Rank: 5/10

--------------------------------------------------

