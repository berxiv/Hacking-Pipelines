==================================================
1. Signature-Based Detection – Evasion Steps
==================================================
2. Open your source code and find every part that looks like shellcode or a static pattern (e.g., a reverse shell IP address, suspicious strings).
3. Change any hardcoded strings (like "cmd.exe" or IPs) into a custom encoding format (e.g., store it as a list of characters and build it at runtime).
4. Add junk code between actual logic blocks (like unused if statements or loops) to change how the final binary looks.
5. Manually reorder function definitions in your code and call them in a less obvious order.
6. Recompile your program regularly to change the binary hash.
7. Add custom sections or rename sections in your compiled executable if you're working at the PE file level.

==================================================
2. Heuristic-Based Detection – Evasion Steps
==================================================
1. Instead of importing Windows API functions directly (like VirtualAlloc), use function pointers:
   * At the start of your program, use LoadLibrary to load kernel32.dll.
   * Use GetProcAddress to get the address of VirtualAlloc and call it using a function pointer.
2. If you use suspicious API functions together (like allocating memory and writing to it), separate them across different functions.
3. Add dummy function calls that make your program look more normal (like printing to console or opening a file).
4. Build your strings character-by-character in a loop instead of writing them as full strings.

==================================================
3. Behavioral-Based Detection – Evasion Steps
==================================================
1. At the beginning of your program, insert a long sleep (e.g., Sleep(30000) for 30 seconds).
2. Check if the mouse has moved recently or if there's any keyboard input:
   * Use GetCursorPos and compare over time.
   * Use GetAsyncKeyState to check for key presses.
3. Don’t run payloads until after user interaction (like pressing a key or clicking a button).
4. Break up actions: do one small thing (like writing a file), then pause and do something else later.

==================================================
4. Cloud-Based Reputation Systems – Evasion Steps
==================================================
1. Write code that doesn't immediately connect to the internet.
2. Wait a long time or only connect after the user interacts with the program.
3. When generating a binary, change something small in your source code (like a variable name or comment) every time before compiling.
4. Write your program to generate random file names or fake version info to make it look like a new program each time.

==================================================
5. Memory Forensics and Scanning – Evasion Steps
==================================================
1. When allocating memory for your payload, do it in two steps:
   * First, use VirtualAlloc to allocate memory with read/write permissions.
   * Write your payload into it.
   * Then, use VirtualProtect to change the memory to read/execute before running it.
2. Don’t leave readable strings in memory. Encrypt them and only decrypt right before using them.
3. After using a string or payload, overwrite it in memory with random values or zeroes.
4. Manually copy your payload into memory instead of loading a DLL to avoid leaving PE headers visible.

==================================================
6. Telemetry Correlation / EDR Analytics – Evasion Steps
==================================================
1. Avoid running obvious chains like Word launching PowerShell. Instead, create your own simple loader program.
2. Use the Windows API to launch other processes in a hidden way:
   * Use CreateProcess with the "CREATE\_NO\_WINDOW" flag.
3. When running commands, avoid calling cmd.exe. Use native functions or script engines like WScript.
4. Spread out the actions of your malware: run a small part now, then the rest after a reboot or delay.
5. Store data in temporary or less-monitored places (like in memory or registry keys not commonly used).

==================================================
7. Machine Learning-Based Detection – Evasion Steps
==================================================
1. Add non-malicious strings and features to your binary to confuse ML systems.
2. Randomly reorder functions and add dummy functions that look like normal software.
3. Change how your program handles common tasks (e.g., instead of calling "MessageBox", use lower-level APIs to do similar things).
4. Use different string and variable names every time you compile.
5. Make your code less suspicious by using consistent formatting, version info, and digital signature fields (even if fake).

==================================================
8. YARA and Custom Rule Detection – Evasion Steps
==================================================
1. Search your code for suspicious strings and break them apart:
   * Instead of "powershell", store it as \["p", "o", "w", "e", "r"] and join it at runtime.
2. Use functions to create common words instead of writing them directly.
3. Change section names and other metadata in your compiled file (if editing PE structure).
4. Insert random data or strings between real code sections to throw off pattern matching.
5. Change every filename, command, and identifier before every test.
